# Study_JavaBase-MSA
자바 기반의 마이크로서비스 이해와 아키텍처 구축하기(박성훈 지음)

## [Settings]

## [Origin Source]
* [출처](https://github.com/architectstory)

---

# 목차별 내용 정리

## Chapter01
마이크로서비스 아키텍처의 이해
* MSA(Micro Service Architecture)

소프트웨어 아키텍처의 정의
* 소프트웨어를 구성하는 요소와 요소 간의 관계를 정의한 청사진(도면)

아키텍처의 표현
* 사람마다 직군, 경험 등을 기준으로 하나의 시스템을 이해하는 수준이 다름
* 표준화된 모델링 언어를 통해 아키텍처를 표현하는 것이 효과적
  * UML(Unified Modeling Language) 등
* 관점 (아키텍처 뷰)
  * Logical View (논리적 뷰)
    * 소프트웨어를 구성하는 요소들의 관계 구조 표현
  * Process View (프로세스 뷰)
    * 소프트웨어 간 동적인 흐름, 스레드, 프로세스 등의 동시성 처리 표현
  * Implementation View (구현 뷰)
    * 논리적인 설계의 실제 구현 측면에서 소프트웨어의 구성, 구조 표현
  * Deployment View (배치 뷰)
    * 시스템에서의 소프트웨어 배치 표현
  * Usecase View (유스케이스 뷰)
    * 시스템의 사용 사례 표현
    * 이를 제외한 위 4개의 표현은 사용 사례를 충족, 표현하기 위한 관점

아키텍처의 역할
* 유연하면서 단단한, 명확한 설계는 오랜 풍파로부터 잘 견딜 수 있게 해줌
  * 개발자의 수고를 덜어주고, 시스템의 성능 등을 좌우
* 구성 요소 간 명확하고 효율적인 역할 관계를 기반으로 탄력적인 아키텍처 형성 가능

소프트웨어 아키텍처 스타일
* 특정 제약 조건에서 아키텍처의 방향, 접근 방법을 의미
  * 자신(요구 조건 등)을 잘 나타내면서 다양한 환경을 잘 수렴하도록 설계
* 시스템 요건을 충족시키기 위한 제약 조건을 가진 아키텍처 측면 접근 방법
* 스타일
  * 상황을 해결할 접근 방법을 제시
* 패턴
  * 시스템이 가지는 문제를 해결할 구체적인 해결 방안을 경험 사례를 기반으로 제시
* MSA도 기존 모놀리스(monolith) 앱 구조의 문제점을 해결하기 위한 접근 방법(스타일)

모놀리스에서 마이크로서비스로 변화
* 일반적으로 모놀리스는 앱에서 사용하는 데이터 또한 한 곳에 두고 참조하는 형태
* 하지만 현대 사회에서는 비즈니스가 빠르고 수시로 변화되며 시스템의 크기가 큼
  * 비즈니스 요구를 빠르게 반영하기가 쉽지 않음
  * 시스템 규모, 복잡도의 증가로 빌드, 배포의 너무 많은 시간과 노력을 할애하게 됨
* 모놀리스의 단점을 극복하고자 앱을 작은 앱으로 나누어 서비스하는 것이 마이크로 서비스

회색지대와 아키텍트
* 회색지대는 업무 영역(+기술적 측면)이 겹치는 애매한 영역
* 팀 간 경계의 틈을 메워주는 것이 아키텍트 집단

아키텍트 역할의 세분화와 변화
* 성공적인 프로젝트를 위해 아키텍트에게는 모든 기술 요소에 대해 높은 이해 수준이 요구됨
* 현대 사회에서 모든 분야에 정통하기는 불가능
  * 따라서 프로젝트가 어떤 아키텍처이건 아키텍트 역할에 대한 구분이 필요
* 아키텍트 역할
  * 소프트웨어
  * 프론트엔드
  * 프레임워크
  * 데이터
  * 인프라
  * 테크니컬
  * 기타

솔루션 아키텍트
* 과거 아키텍트들이 수행한 작업 대부분을 클라우드 플랫폼이 자동화된 기능으로 제공
  * 시스템 리소스 구성 및 할당과 관리, 모니터링, 빌드, 통합, 배포 등의 프로세스를 아래 기술을 기반으로 자동화, 시각화하여 제공
    * IaaS (Infrastructure as a Service)
      * 서버 리소스, 네트워크, 스토리지, 가상화 등을 제공
    * CaaS(Container as a Service)
      * 하이퍼 바이저의 대안인 컨테이너 계층까지 제공
    * PaaS(Platform as a Service)
      * 특정 언어나 프레임워크, 라이브러리 같은 플랫폼까지 제공
    * BaaS(Backend as a Service)
      * 앱 개발자를 위해 클라우드 서비스, 인증(회원 관리), 푸시 알림 등 서비스 제공
    * FaaS(Function as a Service)
      * 특정 이벤트에 반응하는 함수를 등록, 함수를 실행하는 서비스 제공
    * SaaS(Software as a Service)
      * 앱을 서비스 형태로 제공
    * XaaS(X as a Service)
      * 'as a Service'로 통칭되는 것들을 말한다
    * On-Premiss
      * 기존 운영 방식 (하드웨어부터 모든 설정 작업을 직접 수행)
    * 그 외 인증 권한, 모니터링, 로깅, AI 등 전문 기술이 필요한 영역까지 제공
* 따라서 아키텍트들은 새로운 솔루션들을 빠르게 습득, 조합하는 능력도 중요

마이크로서비스 아키텍처의 개념
* 아주 작은 단위로 동작하는 서비스가 구동되도록 시스템, 소프트웨어의 구성과 구성 요소 간 관계를 정의한 아키텍처
  * 서비스 중심 아키텍처
  * 하나의 스타일

모놀리스 아키텍처와의 차이점
* 기존 모놀리스는 앱의 크기, 규모가 클 경우 변경, 배포 등이 어려움
  * MSA는 결합도가 낮은 다수의 서비스로 이루어져 모놀리스에 비하여 쉬움
  * 앱의 기능뿐 아니라 데이터까지 분리하여 격리, 독립된 환경으로 구성되었다는 것이 차이점

서비스 지향 아키텍처 (Service Oriented Architecture)
* 전체 시스템을 데이터 중심이 아닌 서비스 중심으로 설계하는 아키텍처
* 5가지 특징
  * 서비스 계약(서비스 - 서비스 소비자)
    * 약속된 기능 수행, 여러 개의 서비스 버전
  * 서비스의 가용성
    * 타임아웃, 요청 경로 변경 기능
  * 보안
    * 서비스 간 호출 시 보안상 문제 주의
  * 트랜잭션
    * Read/Write DB 저장소 분리시 데이터의 일관성, 실시간 동기화 이슈 주의
    * SOA에서 DB는 BASE(Basically Available Soft State Eventual Consistency) 트랜잭션
      * BASE는 분산 데이터베이스의 특징을 나타내는 개념(기존 RDB의 ACID 개념과 대비)
      * Basically Available
        * Optimistic locking, Queue는 대표적인 기술 메커니즘 (가용성 중시)
        * 다수의 실패에도 가용성 보장, 다수의 스토리지에 저장
      * Soft State
        * 외부 전달 데이터로 상태가 도달된 시점에 갱신되는 것
      * Eventual Consistency
        * 일시적으로 비일관상태가 되어도 결국에는 두 노드의 데이터가 일관성 있는 상태가 되는 성질
  * 서비스 관리
    * 서비스가 많아지면 관계 정리가 필요
    * 과부하, 오류 상황에도 지속 가능한 서비스가 가능하도록 관리 (실시간, 시각화 - 모니터링)

SOA와 MSA간 차이
* 공통점 - 비즈니스 변화의 대응을 위한 서비스 중심의 아키텍처
* 차이점 - 서비스의 상대적 크기, 관심사, 오너십, 기술 구조
  * 서비스의 상대적 크기, 관심사
    * MSA에서 서비스는 작고 한가지의 일에 집중
    * SOA에서 서비스는 비즈니스에 집중
  * 오너십(OwnerShip)
    * MSA에서 서비스는 하나의 작은 팀에서 관리
    * SOA에서 서비스는 서로 다른 팀간의 상호 협업이 반드시 필요
      * 비즈니스 프로세스 흐름과 관련된 서비스를 공유, 연결 및 조합하여 새로운 서비스 구성
  * 서비스 공유의 정도 차이
    * MSA는 서비스 공유의 최소화를 지향
      * 서비스간 결합도를 낮춰 변화에 민첩하고 능동적으로 대응
    * SOA는 되도록 많은 서비스 공유를 지향
      * 서비스의 재사용을 높여 비용 절감, 품질을 높이는 것에 초점
  * 기술 방식의 차이
    * MSA는 서비스의 공유없이 독립적으로 실행되는 것을 지향
      * 필요하면 만들고 필요 없다면 폐기 > 탄력성
      * 독립된 서비스 간 REST API(Restful) 통신, 필요할 때마다 사용
      * REST API를 보고 호출, 결괏값만 활용하여 구현이 쉬움
    * SOA는 많은 서비스 공유를 위해 ESB를 이용하여 서비스 공유, 비즈니스 측면에서 재사용 강조
      * Enterprise Service Bus
      * 흩어져 있는 같은 역할의 서비스를 통합, ESB에 담아 필요할 때마다 사용
      * 통합된 서비스들을 UDDI 이라는 서비스 저장소에 등록  
        WSDL 이라는 서비스 명세서 공유  
        WSDL을 참고하여 stub 클래스를 생성 후 SOAP 통신  
        결합도가 높기 때문에 명세가 변경되는 경우 모든 클라이언트를 변경해야 함
        * UDDI (Universal Description Discovery and Integration)
        * WSDL (Web Service Description Language)
        * SOAP (Simple Object Access Protocol)

|       구분       |            MSA            |             SOA             |
|:----------------:|:-------------------------:|:---------------------------:|
| 사상             | 서비스지향                | 서비스지향                  |
| 서비스 오너십    | 조직(팀) 단위 자율성 부여 | 조직(팀) 간 협업            |
| 서비스 크기      | SOA 대비 작음             | MSA 대비 큼                 |
| 서비스 공유 정보 | 서비스 간 독립            | 서비스 공유                 |
| 서비스 공유 방식 | API                       | 서비스 공유를 위한 미들웨어 |
| 서비스 통신 방식 | RESTful API 등            | SOAP, WSDL, UDDI, ESB 등    |

왜 MSA인가?
* 민첩한 서비스
  * 빠르게 변화하는 현대 비즈니스 환경에 대처하기 위해서는 빠르게 구현, 배포 되어야 함
  * 세분화하여 각각의 조직이 자율적, 독립적으로 서비스를 생성, 배포하여 능동적으로 대처
* 유연한 인프라
  * MSA를 가능케 하는 기술 환경 등장 (클라우드, 컨테이너 등)
  * 서비스 비즈니스와 실현을 도와줄 기술과의 조화
* Happy Path
  * 빠르게 개발, 검증할 수 있는 특성으로 해피 패스를 구현하기에 적절
  * 최소 기능만을 도출하여 향후 방향성 설정, 사전에 결과 체험

정리
* 해당 챕터에서는 MSA에 대한 개념, 특징과 기존 아키텍처와의 차이 등을 정의
* MSA는 DDD, 도커-쿠버네티스 등과 밀접한 관계까 있음
* 마이크로 서비스 간 REST API 뿐 아니라 최근에 나온 gRPC 또한 적용 가능할 것으로 보임

---
